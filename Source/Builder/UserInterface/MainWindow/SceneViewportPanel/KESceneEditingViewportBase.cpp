/*---------------------------------------------------------------------------*\
 *                             Kabala Engine                                 *
 *                                                                           *
 *               Copyright (C) 2009-2010 by David Kabala                     *
 *                                                                           *
 *   authors:  David Kabala (djkabala@gmail.com)                             *
 *                                                                           *
\*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*\
 *                                License                                    *
 *                                                                           *
 * This library is free software; you can redistribute it and/or modify it   *
 * under the terms of the GNU General Public License as published            *
 * by the Free Software Foundation, version 3.                               *
 *                                                                           *
 * This library is distributed in the hope that it will be useful, but       *
 * WITHOUT ANY WARRANTY; without even the implied warranty of                *
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU         *
 * Library General Public License for more details.                          *
 *                                                                           *
 * You should have received a copy of the GNU General Public                 *
 * License along with this library; if not, write to the Free Software       *
 * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.                 *
 *                                                                           *
\*---------------------------------------------------------------------------*/
/*---------------------------------------------------------------------------*\
 *                                Changes                                    *
 *                                                                           *
 *                                                                           *
 *                                                                           *
 *                                                                           *
 *                                                                           *
 *                                                                           *
\*---------------------------------------------------------------------------*/

/*****************************************************************************\
 *****************************************************************************
 **                                                                         **
 **                  This file is automatically generated.                  **
 **                                                                         **
 **          Any changes made to this file WILL be lost when it is          **
 **           regenerated, which can become necessary at any time.          **
 **                                                                         **
 **     Do not change this file, changes should be done in the derived      **
 **     class SceneEditingViewport!
 **                                                                         **
 *****************************************************************************
\*****************************************************************************/

#include <cstdlib>
#include <cstdio>
#include <boost/assign/list_of.hpp>

#include <OpenSG/OSGConfig.h>



#include <OpenSG/OSGGLViewport.h>       // SceneViewports Class
#include <OpenSG/OSGNode.h>             // SelectedNodes Class
#include "Project/Scene/KEScene.h"      // EditingScene Class

#include "KESceneEditingViewportBase.h"
#include "KESceneEditingViewport.h"

#include <boost/bind.hpp>

#ifdef WIN32 // turn off 'this' : used in base member initializer list warning
#pragma warning(disable:4355)
#endif

OSG_BEGIN_NAMESPACE

/***************************************************************************\
 *                            Description                                  *
\***************************************************************************/

/*! \class OSG::SceneEditingViewport
    
 */

/***************************************************************************\
 *                        Field Documentation                              *
\***************************************************************************/

/*! \var GLViewport *    SceneEditingViewportBase::_mfSceneViewports
    
*/

/*! \var GLViewport *    SceneEditingViewportBase::_mfEditorOverlayViewports
    
*/

/*! \var bool            SceneEditingViewportBase::_sfEnableNodeSelection
    
*/

/*! \var bool            SceneEditingViewportBase::_sfEnableTransformControls
    
*/

/*! \var bool            SceneEditingViewportBase::_sfDrawGrid
    
*/

/*! \var bool            SceneEditingViewportBase::_sfDrawLocalAxis
    
*/

/*! \var bool            SceneEditingViewportBase::_sfDrawVolumeBox
    
*/

/*! \var bool            SceneEditingViewportBase::_sfDrawMesh
    
*/

/*! \var Node *          SceneEditingViewportBase::_mfSelectedNodes
    
*/

/*! \var Scene *         SceneEditingViewportBase::_sfEditingScene
    
*/


/***************************************************************************\
 *                      FieldType/FieldTrait Instantiation                 *
\***************************************************************************/

#if !defined(OSG_DO_DOC) || defined(OSG_DOC_DEV)
DataType FieldTraits<SceneEditingViewport *>::_type("SceneEditingViewportPtr", "PanelPtr");
#endif

OSG_FIELDTRAITS_GETTYPE(SceneEditingViewport *)

OSG_EXPORT_PTR_SFIELD_FULL(PointerSField,
                           SceneEditingViewport *,
                           0);

OSG_EXPORT_PTR_MFIELD_FULL(PointerMField,
                           SceneEditingViewport *,
                           0);

/***************************************************************************\
 *                         Field Description                               *
\***************************************************************************/

void SceneEditingViewportBase::classDescInserter(TypeObject &oType)
{
    FieldDescriptionBase *pDesc = NULL;


    pDesc = new MFUnrecGLViewportPtr::Description(
        MFUnrecGLViewportPtr::getClassType(),
        "SceneViewports",
        "",
        SceneViewportsFieldId, SceneViewportsFieldMask,
        false,
        (Field::MFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&SceneEditingViewport::editHandleSceneViewports),
        static_cast<FieldGetMethodSig >(&SceneEditingViewport::getHandleSceneViewports));

    oType.addInitialDesc(pDesc);

    pDesc = new MFUnrecGLViewportPtr::Description(
        MFUnrecGLViewportPtr::getClassType(),
        "EditorOverlayViewports",
        "",
        EditorOverlayViewportsFieldId, EditorOverlayViewportsFieldMask,
        false,
        (Field::MFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&SceneEditingViewport::editHandleEditorOverlayViewports),
        static_cast<FieldGetMethodSig >(&SceneEditingViewport::getHandleEditorOverlayViewports));

    oType.addInitialDesc(pDesc);

    pDesc = new SFBool::Description(
        SFBool::getClassType(),
        "EnableNodeSelection",
        "",
        EnableNodeSelectionFieldId, EnableNodeSelectionFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&SceneEditingViewport::editHandleEnableNodeSelection),
        static_cast<FieldGetMethodSig >(&SceneEditingViewport::getHandleEnableNodeSelection));

    oType.addInitialDesc(pDesc);

    pDesc = new SFBool::Description(
        SFBool::getClassType(),
        "EnableTransformControls",
        "",
        EnableTransformControlsFieldId, EnableTransformControlsFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&SceneEditingViewport::editHandleEnableTransformControls),
        static_cast<FieldGetMethodSig >(&SceneEditingViewport::getHandleEnableTransformControls));

    oType.addInitialDesc(pDesc);

    pDesc = new SFBool::Description(
        SFBool::getClassType(),
        "DrawGrid",
        "",
        DrawGridFieldId, DrawGridFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&SceneEditingViewport::editHandleDrawGrid),
        static_cast<FieldGetMethodSig >(&SceneEditingViewport::getHandleDrawGrid));

    oType.addInitialDesc(pDesc);

    pDesc = new SFBool::Description(
        SFBool::getClassType(),
        "DrawLocalAxis",
        "",
        DrawLocalAxisFieldId, DrawLocalAxisFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&SceneEditingViewport::editHandleDrawLocalAxis),
        static_cast<FieldGetMethodSig >(&SceneEditingViewport::getHandleDrawLocalAxis));

    oType.addInitialDesc(pDesc);

    pDesc = new SFBool::Description(
        SFBool::getClassType(),
        "DrawVolumeBox",
        "",
        DrawVolumeBoxFieldId, DrawVolumeBoxFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&SceneEditingViewport::editHandleDrawVolumeBox),
        static_cast<FieldGetMethodSig >(&SceneEditingViewport::getHandleDrawVolumeBox));

    oType.addInitialDesc(pDesc);

    pDesc = new SFBool::Description(
        SFBool::getClassType(),
        "DrawMesh",
        "",
        DrawMeshFieldId, DrawMeshFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&SceneEditingViewport::editHandleDrawMesh),
        static_cast<FieldGetMethodSig >(&SceneEditingViewport::getHandleDrawMesh));

    oType.addInitialDesc(pDesc);

    pDesc = new MFUnrecNodePtr::Description(
        MFUnrecNodePtr::getClassType(),
        "SelectedNodes",
        "",
        SelectedNodesFieldId, SelectedNodesFieldMask,
        false,
        (Field::MFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&SceneEditingViewport::editHandleSelectedNodes),
        static_cast<FieldGetMethodSig >(&SceneEditingViewport::getHandleSelectedNodes));

    oType.addInitialDesc(pDesc);

    pDesc = new SFUnrecScenePtr::Description(
        SFUnrecScenePtr::getClassType(),
        "EditingScene",
        "",
        EditingSceneFieldId, EditingSceneFieldMask,
        false,
        (Field::SFDefaultFlags | Field::FStdAccess),
        static_cast<FieldEditMethodSig>(&SceneEditingViewport::editHandleEditingScene),
        static_cast<FieldGetMethodSig >(&SceneEditingViewport::getHandleEditingScene));

    oType.addInitialDesc(pDesc);
}


SceneEditingViewportBase::TypeObject SceneEditingViewportBase::_type(
    SceneEditingViewportBase::getClassname(),
    Inherited::getClassname(),
    "NULL",
    0,
    reinterpret_cast<PrototypeCreateF>(&SceneEditingViewportBase::createEmptyLocal),
    SceneEditingViewport::initMethod,
    SceneEditingViewport::exitMethod,
    reinterpret_cast<InitalInsertDescFunc>(&SceneEditingViewport::classDescInserter),
    false,
    0,
    "<?xml version=\"1.0\"?>\n"
    "\n"
    "<FieldContainer\n"
    "\tname=\"SceneEditingViewport\"\n"
    "\tparent=\"Panel\"\n"
    "\tlibrary=\"KabalaEngine\"\n"
    "\tpointerfieldtypes=\"both\"\n"
    "\tstructure=\"concrete\"\n"
    "\tsystemcomponent=\"false\"\n"
    "\tparentsystemcomponent=\"true\"\n"
    "\tdecoratable=\"false\"\n"
    "\tuseLocalIncludes=\"false\"\n"
    "\tlibnamespace=\"KE\"\n"
    "    authors=\"David Kabala (djkabala@gmail.com)                             \"\n"
    ">\n"
    "     <Field\n"
    "          name=\"SceneViewports\"\n"
    "          type=\"GLViewport\"\n"
    "\t\t  category=\"pointer\"\n"
    "          cardinality=\"multi\"\n"
    "          visibility=\"external\"\n"
    "          access=\"protected\"\n"
    "          >\n"
    "\t </Field>\n"
    "     <Field\n"
    "          name=\"EditorOverlayViewports\"\n"
    "          type=\"GLViewport\"\n"
    "\t\t  category=\"pointer\"\n"
    "          cardinality=\"multi\"\n"
    "          visibility=\"external\"\n"
    "          access=\"protected\"\n"
    "          >\n"
    "\t </Field>\n"
    "     <Field\n"
    "          name=\"EnableNodeSelection\"\n"
    "          type=\"bool\"\n"
    "\t\t  category=\"data\"\n"
    "          cardinality=\"single\"\n"
    "          visibility=\"external\"\n"
    "          access=\"public\"\n"
    "          defaultValue=\"true\"\n"
    "          >\n"
    "\t </Field>\n"
    "     <Field\n"
    "          name=\"EnableTransformControls\"\n"
    "          type=\"bool\"\n"
    "\t\t  category=\"data\"\n"
    "          cardinality=\"single\"\n"
    "          visibility=\"external\"\n"
    "          access=\"public\"\n"
    "          defaultValue=\"true\"\n"
    "          >\n"
    "\t </Field>\n"
    "     <Field\n"
    "          name=\"DrawGrid\"\n"
    "          type=\"bool\"\n"
    "\t\t  category=\"data\"\n"
    "          cardinality=\"single\"\n"
    "          visibility=\"external\"\n"
    "          access=\"public\"\n"
    "          defaultValue=\"true\"\n"
    "          >\n"
    "\t </Field>\n"
    "     <Field\n"
    "          name=\"DrawLocalAxis\"\n"
    "          type=\"bool\"\n"
    "\t\t  category=\"data\"\n"
    "          cardinality=\"single\"\n"
    "          visibility=\"external\"\n"
    "          access=\"public\"\n"
    "          defaultValue=\"true\"\n"
    "          >\n"
    "\t </Field>\n"
    "     <Field\n"
    "          name=\"DrawVolumeBox\"\n"
    "          type=\"bool\"\n"
    "\t\t  category=\"data\"\n"
    "          cardinality=\"single\"\n"
    "          visibility=\"external\"\n"
    "          access=\"public\"\n"
    "          defaultValue=\"true\"\n"
    "          >\n"
    "\t </Field>\n"
    "     <Field\n"
    "          name=\"DrawMesh\"\n"
    "          type=\"bool\"\n"
    "\t\t  category=\"data\"\n"
    "          cardinality=\"single\"\n"
    "          visibility=\"external\"\n"
    "          access=\"public\"\n"
    "          defaultValue=\"true\"\n"
    "          >\n"
    "\t </Field>\n"
    "     <Field\n"
    "          name=\"SelectedNodes\"\n"
    "          type=\"Node\"\n"
    "\t\t  category=\"pointer\"\n"
    "          cardinality=\"multi\"\n"
    "          visibility=\"external\"\n"
    "          access=\"public\"\n"
    "          >\n"
    "\t </Field>\n"
    "     <Field\n"
    "          name=\"EditingScene\"\n"
    "          type=\"Scene\"\n"
    "\t\t  category=\"pointer\"\n"
    "          cardinality=\"single\"\n"
    "          visibility=\"external\"\n"
    "          access=\"public\"\n"
    "          defaultValue=\"NULL\"\n"
    "\t\t  fieldHeader=\"Project/Scene/KESceneFields.h\"\n"
    "\t\t  typeHeader=\"Project/Scene/KEScene.h\"\n"
    "          >\n"
    "\t </Field>\n"
    "</FieldContainer>\n",
    ""
    );

/*------------------------------ get -----------------------------------*/

FieldContainerType &SceneEditingViewportBase::getType(void)
{
    return _type;
}

const FieldContainerType &SceneEditingViewportBase::getType(void) const
{
    return _type;
}

UInt32 SceneEditingViewportBase::getContainerSize(void) const
{
    return sizeof(SceneEditingViewport);
}

/*------------------------- decorator get ------------------------------*/


//! Get the SceneEditingViewport::_mfSceneViewports field.
const MFUnrecGLViewportPtr *SceneEditingViewportBase::getMFSceneViewports(void) const
{
    return &_mfSceneViewports;
}

MFUnrecGLViewportPtr *SceneEditingViewportBase::editMFSceneViewports (void)
{
    editMField(SceneViewportsFieldMask, _mfSceneViewports);

    return &_mfSceneViewports;
}

//! Get the SceneEditingViewport::_mfEditorOverlayViewports field.
const MFUnrecGLViewportPtr *SceneEditingViewportBase::getMFEditorOverlayViewports(void) const
{
    return &_mfEditorOverlayViewports;
}

MFUnrecGLViewportPtr *SceneEditingViewportBase::editMFEditorOverlayViewports(void)
{
    editMField(EditorOverlayViewportsFieldMask, _mfEditorOverlayViewports);

    return &_mfEditorOverlayViewports;
}

SFBool *SceneEditingViewportBase::editSFEnableNodeSelection(void)
{
    editSField(EnableNodeSelectionFieldMask);

    return &_sfEnableNodeSelection;
}

const SFBool *SceneEditingViewportBase::getSFEnableNodeSelection(void) const
{
    return &_sfEnableNodeSelection;
}


SFBool *SceneEditingViewportBase::editSFEnableTransformControls(void)
{
    editSField(EnableTransformControlsFieldMask);

    return &_sfEnableTransformControls;
}

const SFBool *SceneEditingViewportBase::getSFEnableTransformControls(void) const
{
    return &_sfEnableTransformControls;
}


SFBool *SceneEditingViewportBase::editSFDrawGrid(void)
{
    editSField(DrawGridFieldMask);

    return &_sfDrawGrid;
}

const SFBool *SceneEditingViewportBase::getSFDrawGrid(void) const
{
    return &_sfDrawGrid;
}


SFBool *SceneEditingViewportBase::editSFDrawLocalAxis(void)
{
    editSField(DrawLocalAxisFieldMask);

    return &_sfDrawLocalAxis;
}

const SFBool *SceneEditingViewportBase::getSFDrawLocalAxis(void) const
{
    return &_sfDrawLocalAxis;
}


SFBool *SceneEditingViewportBase::editSFDrawVolumeBox(void)
{
    editSField(DrawVolumeBoxFieldMask);

    return &_sfDrawVolumeBox;
}

const SFBool *SceneEditingViewportBase::getSFDrawVolumeBox(void) const
{
    return &_sfDrawVolumeBox;
}


SFBool *SceneEditingViewportBase::editSFDrawMesh(void)
{
    editSField(DrawMeshFieldMask);

    return &_sfDrawMesh;
}

const SFBool *SceneEditingViewportBase::getSFDrawMesh(void) const
{
    return &_sfDrawMesh;
}


//! Get the SceneEditingViewport::_mfSelectedNodes field.
const MFUnrecNodePtr *SceneEditingViewportBase::getMFSelectedNodes(void) const
{
    return &_mfSelectedNodes;
}

MFUnrecNodePtr      *SceneEditingViewportBase::editMFSelectedNodes  (void)
{
    editMField(SelectedNodesFieldMask, _mfSelectedNodes);

    return &_mfSelectedNodes;
}

//! Get the SceneEditingViewport::_sfEditingScene field.
const SFUnrecScenePtr *SceneEditingViewportBase::getSFEditingScene(void) const
{
    return &_sfEditingScene;
}

SFUnrecScenePtr     *SceneEditingViewportBase::editSFEditingScene   (void)
{
    editSField(EditingSceneFieldMask);

    return &_sfEditingScene;
}



void SceneEditingViewportBase::pushToSceneViewports(GLViewport * const value)
{
    editMField(SceneViewportsFieldMask, _mfSceneViewports);

    _mfSceneViewports.push_back(value);
}

void SceneEditingViewportBase::assignSceneViewports(const MFUnrecGLViewportPtr &value)
{
    MFUnrecGLViewportPtr::const_iterator elemIt  =
        value.begin();
    MFUnrecGLViewportPtr::const_iterator elemEnd =
        value.end  ();

    static_cast<SceneEditingViewport *>(this)->clearSceneViewports();

    while(elemIt != elemEnd)
    {
        this->pushToSceneViewports(*elemIt);

        ++elemIt;
    }
}

void SceneEditingViewportBase::removeFromSceneViewports(UInt32 uiIndex)
{
    if(uiIndex < _mfSceneViewports.size())
    {
        editMField(SceneViewportsFieldMask, _mfSceneViewports);

        _mfSceneViewports.erase(uiIndex);
    }
}

void SceneEditingViewportBase::removeObjFromSceneViewports(GLViewport * const value)
{
    Int32 iElemIdx = _mfSceneViewports.findIndex(value);

    if(iElemIdx != -1)
    {
        editMField(SceneViewportsFieldMask, _mfSceneViewports);

        _mfSceneViewports.erase(iElemIdx);
    }
}
void SceneEditingViewportBase::clearSceneViewports(void)
{
    editMField(SceneViewportsFieldMask, _mfSceneViewports);


    _mfSceneViewports.clear();
}

void SceneEditingViewportBase::pushToEditorOverlayViewports(GLViewport * const value)
{
    editMField(EditorOverlayViewportsFieldMask, _mfEditorOverlayViewports);

    _mfEditorOverlayViewports.push_back(value);
}

void SceneEditingViewportBase::assignEditorOverlayViewports(const MFUnrecGLViewportPtr &value)
{
    MFUnrecGLViewportPtr::const_iterator elemIt  =
        value.begin();
    MFUnrecGLViewportPtr::const_iterator elemEnd =
        value.end  ();

    static_cast<SceneEditingViewport *>(this)->clearEditorOverlayViewports();

    while(elemIt != elemEnd)
    {
        this->pushToEditorOverlayViewports(*elemIt);

        ++elemIt;
    }
}

void SceneEditingViewportBase::removeFromEditorOverlayViewports(UInt32 uiIndex)
{
    if(uiIndex < _mfEditorOverlayViewports.size())
    {
        editMField(EditorOverlayViewportsFieldMask, _mfEditorOverlayViewports);

        _mfEditorOverlayViewports.erase(uiIndex);
    }
}

void SceneEditingViewportBase::removeObjFromEditorOverlayViewports(GLViewport * const value)
{
    Int32 iElemIdx = _mfEditorOverlayViewports.findIndex(value);

    if(iElemIdx != -1)
    {
        editMField(EditorOverlayViewportsFieldMask, _mfEditorOverlayViewports);

        _mfEditorOverlayViewports.erase(iElemIdx);
    }
}
void SceneEditingViewportBase::clearEditorOverlayViewports(void)
{
    editMField(EditorOverlayViewportsFieldMask, _mfEditorOverlayViewports);


    _mfEditorOverlayViewports.clear();
}

void SceneEditingViewportBase::pushToSelectedNodes(Node * const value)
{
    editMField(SelectedNodesFieldMask, _mfSelectedNodes);

    _mfSelectedNodes.push_back(value);
}

void SceneEditingViewportBase::assignSelectedNodes(const MFUnrecNodePtr    &value)
{
    MFUnrecNodePtr   ::const_iterator elemIt  =
        value.begin();
    MFUnrecNodePtr   ::const_iterator elemEnd =
        value.end  ();

    static_cast<SceneEditingViewport *>(this)->clearSelectedNodes();

    while(elemIt != elemEnd)
    {
        this->pushToSelectedNodes(*elemIt);

        ++elemIt;
    }
}

void SceneEditingViewportBase::removeFromSelectedNodes(UInt32 uiIndex)
{
    if(uiIndex < _mfSelectedNodes.size())
    {
        editMField(SelectedNodesFieldMask, _mfSelectedNodes);

        _mfSelectedNodes.erase(uiIndex);
    }
}

void SceneEditingViewportBase::removeObjFromSelectedNodes(Node * const value)
{
    Int32 iElemIdx = _mfSelectedNodes.findIndex(value);

    if(iElemIdx != -1)
    {
        editMField(SelectedNodesFieldMask, _mfSelectedNodes);

        _mfSelectedNodes.erase(iElemIdx);
    }
}
void SceneEditingViewportBase::clearSelectedNodes(void)
{
    editMField(SelectedNodesFieldMask, _mfSelectedNodes);


    _mfSelectedNodes.clear();
}



/*------------------------------ access -----------------------------------*/

UInt32 SceneEditingViewportBase::getBinSize(ConstFieldMaskArg whichField)
{
    UInt32 returnValue = Inherited::getBinSize(whichField);

    if(FieldBits::NoField != (SceneViewportsFieldMask & whichField))
    {
        returnValue += _mfSceneViewports.getBinSize();
    }
    if(FieldBits::NoField != (EditorOverlayViewportsFieldMask & whichField))
    {
        returnValue += _mfEditorOverlayViewports.getBinSize();
    }
    if(FieldBits::NoField != (EnableNodeSelectionFieldMask & whichField))
    {
        returnValue += _sfEnableNodeSelection.getBinSize();
    }
    if(FieldBits::NoField != (EnableTransformControlsFieldMask & whichField))
    {
        returnValue += _sfEnableTransformControls.getBinSize();
    }
    if(FieldBits::NoField != (DrawGridFieldMask & whichField))
    {
        returnValue += _sfDrawGrid.getBinSize();
    }
    if(FieldBits::NoField != (DrawLocalAxisFieldMask & whichField))
    {
        returnValue += _sfDrawLocalAxis.getBinSize();
    }
    if(FieldBits::NoField != (DrawVolumeBoxFieldMask & whichField))
    {
        returnValue += _sfDrawVolumeBox.getBinSize();
    }
    if(FieldBits::NoField != (DrawMeshFieldMask & whichField))
    {
        returnValue += _sfDrawMesh.getBinSize();
    }
    if(FieldBits::NoField != (SelectedNodesFieldMask & whichField))
    {
        returnValue += _mfSelectedNodes.getBinSize();
    }
    if(FieldBits::NoField != (EditingSceneFieldMask & whichField))
    {
        returnValue += _sfEditingScene.getBinSize();
    }

    return returnValue;
}

void SceneEditingViewportBase::copyToBin(BinaryDataHandler &pMem,
                                  ConstFieldMaskArg  whichField)
{
    Inherited::copyToBin(pMem, whichField);

    if(FieldBits::NoField != (SceneViewportsFieldMask & whichField))
    {
        _mfSceneViewports.copyToBin(pMem);
    }
    if(FieldBits::NoField != (EditorOverlayViewportsFieldMask & whichField))
    {
        _mfEditorOverlayViewports.copyToBin(pMem);
    }
    if(FieldBits::NoField != (EnableNodeSelectionFieldMask & whichField))
    {
        _sfEnableNodeSelection.copyToBin(pMem);
    }
    if(FieldBits::NoField != (EnableTransformControlsFieldMask & whichField))
    {
        _sfEnableTransformControls.copyToBin(pMem);
    }
    if(FieldBits::NoField != (DrawGridFieldMask & whichField))
    {
        _sfDrawGrid.copyToBin(pMem);
    }
    if(FieldBits::NoField != (DrawLocalAxisFieldMask & whichField))
    {
        _sfDrawLocalAxis.copyToBin(pMem);
    }
    if(FieldBits::NoField != (DrawVolumeBoxFieldMask & whichField))
    {
        _sfDrawVolumeBox.copyToBin(pMem);
    }
    if(FieldBits::NoField != (DrawMeshFieldMask & whichField))
    {
        _sfDrawMesh.copyToBin(pMem);
    }
    if(FieldBits::NoField != (SelectedNodesFieldMask & whichField))
    {
        _mfSelectedNodes.copyToBin(pMem);
    }
    if(FieldBits::NoField != (EditingSceneFieldMask & whichField))
    {
        _sfEditingScene.copyToBin(pMem);
    }
}

void SceneEditingViewportBase::copyFromBin(BinaryDataHandler &pMem,
                                    ConstFieldMaskArg  whichField)
{
    Inherited::copyFromBin(pMem, whichField);

    if(FieldBits::NoField != (SceneViewportsFieldMask & whichField))
    {
        _mfSceneViewports.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (EditorOverlayViewportsFieldMask & whichField))
    {
        _mfEditorOverlayViewports.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (EnableNodeSelectionFieldMask & whichField))
    {
        _sfEnableNodeSelection.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (EnableTransformControlsFieldMask & whichField))
    {
        _sfEnableTransformControls.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (DrawGridFieldMask & whichField))
    {
        _sfDrawGrid.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (DrawLocalAxisFieldMask & whichField))
    {
        _sfDrawLocalAxis.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (DrawVolumeBoxFieldMask & whichField))
    {
        _sfDrawVolumeBox.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (DrawMeshFieldMask & whichField))
    {
        _sfDrawMesh.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (SelectedNodesFieldMask & whichField))
    {
        _mfSelectedNodes.copyFromBin(pMem);
    }
    if(FieldBits::NoField != (EditingSceneFieldMask & whichField))
    {
        _sfEditingScene.copyFromBin(pMem);
    }
}

//! create a new instance of the class
SceneEditingViewportTransitPtr SceneEditingViewportBase::createLocal(BitVector bFlags)
{
    SceneEditingViewportTransitPtr fc;

    if(getClassType().getPrototype() != NULL)
    {
        FieldContainerTransitPtr tmpPtr =
            getClassType().getPrototype()-> shallowCopyLocal(bFlags);

        fc = dynamic_pointer_cast<SceneEditingViewport>(tmpPtr);
    }

    return fc;
}

//! create a new instance of the class, copy the container flags
SceneEditingViewportTransitPtr SceneEditingViewportBase::createDependent(BitVector bFlags)
{
    SceneEditingViewportTransitPtr fc;

    if(getClassType().getPrototype() != NULL)
    {
        FieldContainerTransitPtr tmpPtr =
            getClassType().getPrototype()-> shallowCopyDependent(bFlags);

        fc = dynamic_pointer_cast<SceneEditingViewport>(tmpPtr);
    }

    return fc;
}

//! create a new instance of the class
SceneEditingViewportTransitPtr SceneEditingViewportBase::create(void)
{
    SceneEditingViewportTransitPtr fc;

    if(getClassType().getPrototype() != NULL)
    {
        FieldContainerTransitPtr tmpPtr =
            getClassType().getPrototype()-> shallowCopy();

        fc = dynamic_pointer_cast<SceneEditingViewport>(tmpPtr);
    }

    return fc;
}

SceneEditingViewport *SceneEditingViewportBase::createEmptyLocal(BitVector bFlags)
{
    SceneEditingViewport *returnValue;

    newPtr<SceneEditingViewport>(returnValue, bFlags);

    returnValue->_pFieldFlags->_bNamespaceMask &= ~bFlags;

    return returnValue;
}

//! create an empty new instance of the class, do not copy the prototype
SceneEditingViewport *SceneEditingViewportBase::createEmpty(void)
{
    SceneEditingViewport *returnValue;

    newPtr<SceneEditingViewport>(returnValue, Thread::getCurrentLocalFlags());

    returnValue->_pFieldFlags->_bNamespaceMask &=
        ~Thread::getCurrentLocalFlags();

    return returnValue;
}


FieldContainerTransitPtr SceneEditingViewportBase::shallowCopyLocal(
    BitVector bFlags) const
{
    SceneEditingViewport *tmpPtr;

    newPtr(tmpPtr, dynamic_cast<const SceneEditingViewport *>(this), bFlags);

    FieldContainerTransitPtr returnValue(tmpPtr);

    tmpPtr->_pFieldFlags->_bNamespaceMask &= ~bFlags;

    return returnValue;
}

FieldContainerTransitPtr SceneEditingViewportBase::shallowCopyDependent(
    BitVector bFlags) const
{
    SceneEditingViewport *tmpPtr;

    newPtr(tmpPtr, dynamic_cast<const SceneEditingViewport *>(this), ~bFlags);

    FieldContainerTransitPtr returnValue(tmpPtr);

    tmpPtr->_pFieldFlags->_bNamespaceMask = bFlags;

    return returnValue;
}

FieldContainerTransitPtr SceneEditingViewportBase::shallowCopy(void) const
{
    SceneEditingViewport *tmpPtr;

    newPtr(tmpPtr,
           dynamic_cast<const SceneEditingViewport *>(this),
           Thread::getCurrentLocalFlags());

    tmpPtr->_pFieldFlags->_bNamespaceMask &= ~Thread::getCurrentLocalFlags();

    FieldContainerTransitPtr returnValue(tmpPtr);

    return returnValue;
}



/*------------------------- constructors ----------------------------------*/

SceneEditingViewportBase::SceneEditingViewportBase(void) :
    Inherited(),
    _mfSceneViewports         (),
    _mfEditorOverlayViewports (),
    _sfEnableNodeSelection    (bool(true)),
    _sfEnableTransformControls(bool(true)),
    _sfDrawGrid               (bool(true)),
    _sfDrawLocalAxis          (bool(true)),
    _sfDrawVolumeBox          (bool(true)),
    _sfDrawMesh               (bool(true)),
    _mfSelectedNodes          (),
    _sfEditingScene           (NULL)
{
}

SceneEditingViewportBase::SceneEditingViewportBase(const SceneEditingViewportBase &source) :
    Inherited(source),
    _mfSceneViewports         (),
    _mfEditorOverlayViewports (),
    _sfEnableNodeSelection    (source._sfEnableNodeSelection    ),
    _sfEnableTransformControls(source._sfEnableTransformControls),
    _sfDrawGrid               (source._sfDrawGrid               ),
    _sfDrawLocalAxis          (source._sfDrawLocalAxis          ),
    _sfDrawVolumeBox          (source._sfDrawVolumeBox          ),
    _sfDrawMesh               (source._sfDrawMesh               ),
    _mfSelectedNodes          (),
    _sfEditingScene           (NULL)
{
}


/*-------------------------- destructors ----------------------------------*/

SceneEditingViewportBase::~SceneEditingViewportBase(void)
{
}

void SceneEditingViewportBase::onCreate(const SceneEditingViewport *source)
{
    Inherited::onCreate(source);

    if(source != NULL)
    {
        SceneEditingViewport *pThis = static_cast<SceneEditingViewport *>(this);

        MFUnrecGLViewportPtr::const_iterator SceneViewportsIt  =
            source->_mfSceneViewports.begin();
        MFUnrecGLViewportPtr::const_iterator SceneViewportsEnd =
            source->_mfSceneViewports.end  ();

        while(SceneViewportsIt != SceneViewportsEnd)
        {
            pThis->pushToSceneViewports(*SceneViewportsIt);

            ++SceneViewportsIt;
        }

        MFUnrecGLViewportPtr::const_iterator EditorOverlayViewportsIt  =
            source->_mfEditorOverlayViewports.begin();
        MFUnrecGLViewportPtr::const_iterator EditorOverlayViewportsEnd =
            source->_mfEditorOverlayViewports.end  ();

        while(EditorOverlayViewportsIt != EditorOverlayViewportsEnd)
        {
            pThis->pushToEditorOverlayViewports(*EditorOverlayViewportsIt);

            ++EditorOverlayViewportsIt;
        }

        MFUnrecNodePtr::const_iterator SelectedNodesIt  =
            source->_mfSelectedNodes.begin();
        MFUnrecNodePtr::const_iterator SelectedNodesEnd =
            source->_mfSelectedNodes.end  ();

        while(SelectedNodesIt != SelectedNodesEnd)
        {
            pThis->pushToSelectedNodes(*SelectedNodesIt);

            ++SelectedNodesIt;
        }

        pThis->setEditingScene(source->getEditingScene());
    }
}

GetFieldHandlePtr SceneEditingViewportBase::getHandleSceneViewports  (void) const
{
    MFUnrecGLViewportPtr::GetHandlePtr returnValue(
        new  MFUnrecGLViewportPtr::GetHandle(
             &_mfSceneViewports,
             this->getType().getFieldDesc(SceneViewportsFieldId),
             const_cast<SceneEditingViewportBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr SceneEditingViewportBase::editHandleSceneViewports (void)
{
    MFUnrecGLViewportPtr::EditHandlePtr returnValue(
        new  MFUnrecGLViewportPtr::EditHandle(
             &_mfSceneViewports,
             this->getType().getFieldDesc(SceneViewportsFieldId),
             this));

    returnValue->setAddMethod(
        boost::bind(&SceneEditingViewport::pushToSceneViewports,
                    static_cast<SceneEditingViewport *>(this), _1));
    returnValue->setRemoveMethod(
        boost::bind(&SceneEditingViewport::removeFromSceneViewports,
                    static_cast<SceneEditingViewport *>(this), _1));
    returnValue->setRemoveObjMethod(
        boost::bind(&SceneEditingViewport::removeObjFromSceneViewports,
                    static_cast<SceneEditingViewport *>(this), _1));
    returnValue->setClearMethod(
        boost::bind(&SceneEditingViewport::clearSceneViewports,
                    static_cast<SceneEditingViewport *>(this)));

    editMField(SceneViewportsFieldMask, _mfSceneViewports);

    return returnValue;
}

GetFieldHandlePtr SceneEditingViewportBase::getHandleEditorOverlayViewports (void) const
{
    MFUnrecGLViewportPtr::GetHandlePtr returnValue(
        new  MFUnrecGLViewportPtr::GetHandle(
             &_mfEditorOverlayViewports,
             this->getType().getFieldDesc(EditorOverlayViewportsFieldId),
             const_cast<SceneEditingViewportBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr SceneEditingViewportBase::editHandleEditorOverlayViewports(void)
{
    MFUnrecGLViewportPtr::EditHandlePtr returnValue(
        new  MFUnrecGLViewportPtr::EditHandle(
             &_mfEditorOverlayViewports,
             this->getType().getFieldDesc(EditorOverlayViewportsFieldId),
             this));

    returnValue->setAddMethod(
        boost::bind(&SceneEditingViewport::pushToEditorOverlayViewports,
                    static_cast<SceneEditingViewport *>(this), _1));
    returnValue->setRemoveMethod(
        boost::bind(&SceneEditingViewport::removeFromEditorOverlayViewports,
                    static_cast<SceneEditingViewport *>(this), _1));
    returnValue->setRemoveObjMethod(
        boost::bind(&SceneEditingViewport::removeObjFromEditorOverlayViewports,
                    static_cast<SceneEditingViewport *>(this), _1));
    returnValue->setClearMethod(
        boost::bind(&SceneEditingViewport::clearEditorOverlayViewports,
                    static_cast<SceneEditingViewport *>(this)));

    editMField(EditorOverlayViewportsFieldMask, _mfEditorOverlayViewports);

    return returnValue;
}

GetFieldHandlePtr SceneEditingViewportBase::getHandleEnableNodeSelection (void) const
{
    SFBool::GetHandlePtr returnValue(
        new  SFBool::GetHandle(
             &_sfEnableNodeSelection,
             this->getType().getFieldDesc(EnableNodeSelectionFieldId),
             const_cast<SceneEditingViewportBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr SceneEditingViewportBase::editHandleEnableNodeSelection(void)
{
    SFBool::EditHandlePtr returnValue(
        new  SFBool::EditHandle(
             &_sfEnableNodeSelection,
             this->getType().getFieldDesc(EnableNodeSelectionFieldId),
             this));


    editSField(EnableNodeSelectionFieldMask);

    return returnValue;
}

GetFieldHandlePtr SceneEditingViewportBase::getHandleEnableTransformControls (void) const
{
    SFBool::GetHandlePtr returnValue(
        new  SFBool::GetHandle(
             &_sfEnableTransformControls,
             this->getType().getFieldDesc(EnableTransformControlsFieldId),
             const_cast<SceneEditingViewportBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr SceneEditingViewportBase::editHandleEnableTransformControls(void)
{
    SFBool::EditHandlePtr returnValue(
        new  SFBool::EditHandle(
             &_sfEnableTransformControls,
             this->getType().getFieldDesc(EnableTransformControlsFieldId),
             this));


    editSField(EnableTransformControlsFieldMask);

    return returnValue;
}

GetFieldHandlePtr SceneEditingViewportBase::getHandleDrawGrid        (void) const
{
    SFBool::GetHandlePtr returnValue(
        new  SFBool::GetHandle(
             &_sfDrawGrid,
             this->getType().getFieldDesc(DrawGridFieldId),
             const_cast<SceneEditingViewportBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr SceneEditingViewportBase::editHandleDrawGrid       (void)
{
    SFBool::EditHandlePtr returnValue(
        new  SFBool::EditHandle(
             &_sfDrawGrid,
             this->getType().getFieldDesc(DrawGridFieldId),
             this));


    editSField(DrawGridFieldMask);

    return returnValue;
}

GetFieldHandlePtr SceneEditingViewportBase::getHandleDrawLocalAxis   (void) const
{
    SFBool::GetHandlePtr returnValue(
        new  SFBool::GetHandle(
             &_sfDrawLocalAxis,
             this->getType().getFieldDesc(DrawLocalAxisFieldId),
             const_cast<SceneEditingViewportBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr SceneEditingViewportBase::editHandleDrawLocalAxis  (void)
{
    SFBool::EditHandlePtr returnValue(
        new  SFBool::EditHandle(
             &_sfDrawLocalAxis,
             this->getType().getFieldDesc(DrawLocalAxisFieldId),
             this));


    editSField(DrawLocalAxisFieldMask);

    return returnValue;
}

GetFieldHandlePtr SceneEditingViewportBase::getHandleDrawVolumeBox   (void) const
{
    SFBool::GetHandlePtr returnValue(
        new  SFBool::GetHandle(
             &_sfDrawVolumeBox,
             this->getType().getFieldDesc(DrawVolumeBoxFieldId),
             const_cast<SceneEditingViewportBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr SceneEditingViewportBase::editHandleDrawVolumeBox  (void)
{
    SFBool::EditHandlePtr returnValue(
        new  SFBool::EditHandle(
             &_sfDrawVolumeBox,
             this->getType().getFieldDesc(DrawVolumeBoxFieldId),
             this));


    editSField(DrawVolumeBoxFieldMask);

    return returnValue;
}

GetFieldHandlePtr SceneEditingViewportBase::getHandleDrawMesh        (void) const
{
    SFBool::GetHandlePtr returnValue(
        new  SFBool::GetHandle(
             &_sfDrawMesh,
             this->getType().getFieldDesc(DrawMeshFieldId),
             const_cast<SceneEditingViewportBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr SceneEditingViewportBase::editHandleDrawMesh       (void)
{
    SFBool::EditHandlePtr returnValue(
        new  SFBool::EditHandle(
             &_sfDrawMesh,
             this->getType().getFieldDesc(DrawMeshFieldId),
             this));


    editSField(DrawMeshFieldMask);

    return returnValue;
}

GetFieldHandlePtr SceneEditingViewportBase::getHandleSelectedNodes   (void) const
{
    MFUnrecNodePtr::GetHandlePtr returnValue(
        new  MFUnrecNodePtr::GetHandle(
             &_mfSelectedNodes,
             this->getType().getFieldDesc(SelectedNodesFieldId),
             const_cast<SceneEditingViewportBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr SceneEditingViewportBase::editHandleSelectedNodes  (void)
{
    MFUnrecNodePtr::EditHandlePtr returnValue(
        new  MFUnrecNodePtr::EditHandle(
             &_mfSelectedNodes,
             this->getType().getFieldDesc(SelectedNodesFieldId),
             this));

    returnValue->setAddMethod(
        boost::bind(&SceneEditingViewport::pushToSelectedNodes,
                    static_cast<SceneEditingViewport *>(this), _1));
    returnValue->setRemoveMethod(
        boost::bind(&SceneEditingViewport::removeFromSelectedNodes,
                    static_cast<SceneEditingViewport *>(this), _1));
    returnValue->setRemoveObjMethod(
        boost::bind(&SceneEditingViewport::removeObjFromSelectedNodes,
                    static_cast<SceneEditingViewport *>(this), _1));
    returnValue->setClearMethod(
        boost::bind(&SceneEditingViewport::clearSelectedNodes,
                    static_cast<SceneEditingViewport *>(this)));

    editMField(SelectedNodesFieldMask, _mfSelectedNodes);

    return returnValue;
}

GetFieldHandlePtr SceneEditingViewportBase::getHandleEditingScene    (void) const
{
    SFUnrecScenePtr::GetHandlePtr returnValue(
        new  SFUnrecScenePtr::GetHandle(
             &_sfEditingScene,
             this->getType().getFieldDesc(EditingSceneFieldId),
             const_cast<SceneEditingViewportBase *>(this)));

    return returnValue;
}

EditFieldHandlePtr SceneEditingViewportBase::editHandleEditingScene   (void)
{
    SFUnrecScenePtr::EditHandlePtr returnValue(
        new  SFUnrecScenePtr::EditHandle(
             &_sfEditingScene,
             this->getType().getFieldDesc(EditingSceneFieldId),
             this));

    returnValue->setSetMethod(
        boost::bind(&SceneEditingViewport::setEditingScene,
                    static_cast<SceneEditingViewport *>(this), _1));

    editSField(EditingSceneFieldMask);

    return returnValue;
}



#ifdef OSG_MT_CPTR_ASPECT
void SceneEditingViewportBase::execSyncV(      FieldContainer    &oFrom,
                                        ConstFieldMaskArg  whichField,
                                        AspectOffsetStore &oOffsets,
                                        ConstFieldMaskArg  syncMode,
                                  const UInt32             uiSyncInfo)
{
    SceneEditingViewport *pThis = static_cast<SceneEditingViewport *>(this);

    pThis->execSync(static_cast<SceneEditingViewport *>(&oFrom),
                    whichField,
                    oOffsets,
                    syncMode,
                    uiSyncInfo);
}
#endif


#ifdef OSG_MT_CPTR_ASPECT
FieldContainer *SceneEditingViewportBase::createAspectCopy(
    const FieldContainer *pRefAspect) const
{
    SceneEditingViewport *returnValue;

    newAspectCopy(returnValue,
                  dynamic_cast<const SceneEditingViewport *>(pRefAspect),
                  dynamic_cast<const SceneEditingViewport *>(this));

    return returnValue;
}
#endif

void SceneEditingViewportBase::resolveLinks(void)
{
    Inherited::resolveLinks();

    static_cast<SceneEditingViewport *>(this)->clearSceneViewports();

    static_cast<SceneEditingViewport *>(this)->clearEditorOverlayViewports();

    static_cast<SceneEditingViewport *>(this)->clearSelectedNodes();

    static_cast<SceneEditingViewport *>(this)->setEditingScene(NULL);


}


OSG_END_NAMESPACE
